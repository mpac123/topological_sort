import random 

# - the graph is generated by randomly connecting vertices
# - every vertex has its degree
# - vertices with lower degree can be connected only with vertices of higher degree
#   in order to mantain the graph acyclic

# the amount of vertices with of a degree is chosen randomly from a given range 
# for every degree
MIN_PER_DEGREE = 1
MAX_PER_DEGREE = 5

# the probablility of two vertives of different degrees being connected
# is randomly chosen from the given range for every graph
MIN_PROBABILITY = 0.3
MAX_PROBABILITY = 0.8

# the vertices and edges will be generated until the given
# complexity coefficient is met

def generate_graph(complexity_coefficient):
    # complecity_coefficient = |V| + |E|
    
    # get random probability
    probability = MIN_PROBABILITY + (random.random() * (MAX_PROBABILITY - MIN_PROBABILITY))
    # initialize graph
    graph = {}

    # initialize edge and vertex counters
    v_cnt = 0
    e_cnt = 0

    while (v_cnt + e_cnt < complexity_coefficient):
        # get random amount of vertices for this degree
        per_degree = random.randint(MIN_PER_DEGREE, MAX_PER_DEGREE)
        for V in range(1, per_degree + 1):
            graph[v_cnt + V] = []
            if (v_cnt + V + e_cnt >= complexity_coefficient):
                return graph
        

        for lower_degree_V in range(1, v_cnt + 1):
            for new_V_ind in range(1, per_degree + 1):
                if (random.random() <= probability):
                    graph[lower_degree_V].append(v_cnt + new_V_ind)
                    e_cnt += 1
                    if (v_cnt + e_cnt + per_degree >= complexity_coefficient):
                        return graph
        v_cnt += per_degree

    
    return graph


        